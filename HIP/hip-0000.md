---
hip: 0000
title: Extending HTS with NFT support
author: Daniel Ivanov (@Daniel-K-Ivanov)
type: Service
status: Draft
created: 2021-04-22
discussions-to: TODO
---

## Abstract

The HIP defines the changes that must be applied in order for Hedera Services to support Non-fungible tokens.

## Motivation

The growing demand and use-cases for tokenisation point out that the current HTS design does not support all of the needs of the community. In this HIP we would like to describe a set of changes that would enable non-fungible types of tokens to be issues natively on Hedera Hashgraph. Having support for such tokens enable additional applications to be built on top of HTS.

## Rationale

Since developers desire the tokenization APIs to look similar for both fungible and non-fungible tokens, it is worth considering creating a single set of APIs that work for both.

Though fungible and non-fungible tokens are different, there are a lot of commonalities - eg admin keys, KYC, supply, mint and burn behaviours. 

## Specification

Based on the [IWA specification](https://github.com/InterWorkAlliance/TokenTaxonomyFramework) we can distinguish the following combinations of fungible and non-fungible tokens:

```
 HTS
│
└─── Fungible
│   └─── Fractional
│   └─── Whole         
└─── Non-Fungible
    └─── Whole              
    └─── Fractional
    └─── Singleton    
```

### Fungible

Tokens that have interchangeable value with one another, where any quantity of them has the same value as another equal quantity if they are in the same class or series 

#### Fractional
Describes a token that can be divided into smaller fractions, represented as decimals. The current version of HTS supports these types of tokens. They can be implicitly defined and created by setting `decimals != 0`. 

#### Whole
Describes a token that cannot be divided into smaller fractions. Meaning that subdivision is not allowed - just whole number quantities. Current version of HTS supports these types of tokens. They can be implicitly defined and created by setting `decimals=0`.

### Non-fungible
The NFT type is not interchangeable with other tokens of the same type as they typically have different values. 

#### Whole
Each instance of a token in the class can share some property values with other tokens in the class and have distincly unique values between them. They cannot be divided into smaller fractions, represented as decimals.

#### Fractional
Similar to `Whole` in terms that each instance of a token in the class can share some property values with other tokens in the class and have distincly unique values between them, but compared to `Whole`, they CAN be divided into smaller fractions.

#### Singleton
There can only be one instance in the deployed token class and that instance is indivisible. Useful when there is an asset or object to be tokenized that shares no properties or values with any other object.

## HAPI Changes

Described below are the set of changes that must be applied to the HTS API in order to support the described types above as-well as the additional operations and message types that should be added.

### Modification of current HAPI messages

The following protobuf messages to be changed.
#### TokenCreateTransactionBody

```diff
+//Fungible or Non-Fungible Token Base. Cannot be updated using admin key
+enum TokenType {
+	FUNGIBLE = 0;
+	NON_FUNGIBLE = 1;
+}

message TokenCreateTransactionBody {
+	TokenType tokenType = xx; // IWA compatibility. Specifies fungible or not
	string name = 1; // The publicly visible name of the token, limited to a UTF-8 encoding of length <tt>tokens.maxSymbolUtf8Bytes</tt>.
   	string symbol = 2; // The publicly visible token symbol, limited to a UTF-8 encoding of length <tt>tokens.maxTokenNameUtf8Bytes</tt>
!	uint32 decimals = 3; // The number of decimal places a token is divisible by. This field can never be changed! For NFTType decimals must be 0. 
+	uint64 maxSupply = xx; // IWA Compatibility. Cannot be updated using admin key. Maximum number of fungible tokens that can be in circulation or in the case for NFT Type - the maximum number of NFTs (serial numbers) that can be minted.
!	uint64 initialSupply = 4; // Specifies the initial supply of tokens to be put in circulation. The initial supply is sent to the Treasury Account. The supply is in the lowest denomination possible. In the case for NFT Type the value must be 0
!   	AccountID treasury = 5; // The account which will act as a treasury for the token. This account will receive the specified initial supply or the newly minted NFTs in the case for NFT Type
	Key adminKey = 6; // The key which can perform update/delete operations on the token. If empty, the token can be perceived as immutable (not being able to be updated/deleted)
   	Key kycKey = 7; // The key which can grant or revoke KYC of an account for the token's transactions. If empty, KYC is not required, and KYC grant or revoke operations are not possible.
   	Key freezeKey = 8; // The key which can sign to freeze or unfreeze an account for token transactions. If empty, freezing is not possible
   	Key wipeKey = 9; // The key which can wipe the token balance of an account. If empty, wipe is not possible
   	Key supplyKey = 10; // The key which can change the supply of a token. The key is used to sign Token Mint/Burn operations
   	bool freezeDefault = 11; // The default Freeze status (frozen or unfrozen) of Hedera accounts relative to this token. If true, an account must be unfrozen before it can receive the token
	Timestamp expiry = 13; // The epoch second at which the token should expire; if an auto-renew account and period are specified, this is coerced to the current epoch second plus the autoRenewPeriod
   	AccountID autoRenewAccount = 14; // An account which will be automatically charged to renew the token's expiration, at autoRenewPeriod interval
   	Duration autoRenewPeriod = 15; // The interval at which the auto-renew account will be charged to extend the token's expiry
   	string memo = 16; // The memo associated with the token (UTF-8 encoding max 100 bytes)
}
```

#### TokenAssociateTransactionBody 

```diff
message TokenAssociateTransactionBody {
    AccountID account = 1; // The account to be associated with the provided tokens
!   repeated TokenID tokens = 2; // The tokens to be associated with the provided account. In the case of NFT Type, once an account is associated, it can hold any number of NFTs (serial numbers) of that token type.
}
```

#### TokenMintTransactionBody

Once created, an NFT cannot be updated, only transferred/wiped or burned.
```diff
message TokenMintTransactionBody {
    TokenID token = 1; // The token for which to mint tokens. If token does not exist, transaction results in INVALID_TOKEN_ID
!   uint64 amount = 2; // The amount to mint to the Treasury Account. Amount must be a positive non-zero number represented in the lowest denomination of the token. The new supply must be lower than 2^63. It is used to determine the supply of the NFT being minted for tokens with `NftType`. Depending on the value it can represent different types of NFTs Hybrid/Fractional/Whole or Singleton. If 1 is specified, the NFT instance created will be 1 out of 1, thus representing `singleton` If amount is 0, response code INVALID_AMOUNT should be returned. If amount is greater than 1, the NFT can be considred "Hybrid" based on the IWA specification
+   bytes meta = 3; // The metadata for the given NFT instance that is being created. Ignored and not applicable for tokens of type `FUNGIBLE`
}

```
#### TokenBurnTransactionBody

```diff
+// List of serial numbers to be burned and the corresponding amounts
+message SerialNumberAmount {
+     uint serialNumber
+      sint64 amount+
+}

+message AmountOrSerialNumbersList {
+	oneof {
+		amount = 3; //Applicable to tokens of type FUNGIBLE. Amount of fungible tokens to burn
+		Repeated SerialNumberAmount: 4; //Applicable to tokens of type NON_FUNGIBLE.
+	}
+}


message TokenBurnTransactionBody {
	TokenID token = 1; // The token for which to burn tokens. If token does not exist, transaction results in INVALID_TOKEN_ID
!	uint64 amount = 2; [deprecated=true] // The amount to burn from the Treasury Account. Amount must be a positive non-zero number, not bigger than the token balance of the treasury account (0; balance], represented in the lowest denomination.
+	AmountOrSerialNumbersList= 3; // Defines the amount of serialnumbers to be burned
}
```

#### TokenWipeAccountTransactionBody

```diff
message TokenWipeAccountTransactionBody {
	TokenID token = 1; // The token for which the account will be wiped. If token does not exist, transaction results in INVALID_TOKEN_ID
	AccountID account = 2; // The account to be wiped
!	uint64 amount = 3; [deprecated=true] // The amount of tokens to wipe from the specified account. Amount must be a positive non-zero number in the lowest denomination possible, not bigger than the token balance of the account (0; balance]
+	AmountOrSerialNumbersList= 3; // Defines the amount of serialnumbers to be wiped
}

```

#### TransactionReceipt

#### TokenInfo

#### TokenTransferList

### New HAPI Messages

### Other

## Backwards Compatibility

## Security Implicattions

## How to Teach This

## Reference implementation

## Rejected Ideas

## Open Issues

## References

## Copyright/license

